import type { Context } from '@emnapi/runtime';

/** @public */
export declare type BaseCreateOptions = {
    filename?: string
    nodeBinding?: NodeBinding
    reuseWorker?: boolean
    asyncWorkPoolSize?: number
    onCreateWorker?: (info: CreateWorkerInfo) => any
    print?: (str: string) => void
    printErr?: (str: string) => void
    postMessage?: (msg: any) => any
}

/** @public */
export declare function createNapiModule (
options: CreateOptions
): NapiModule

/** @public */
export declare type CreateOptions = BaseCreateOptions & ({
    context: Context
    childThread?: boolean
} | {
    context?: Context
    childThread: true
})

/** @public */
export declare interface CreateWorkerInfo {
    type: 'thread' | 'async-work'
}

/** @public */
export declare interface HandleOptions {
    onLoad(data: OnLoadData): InstantiatedSource | Promise<InstantiatedSource>;
}

/** @public */
export declare interface InitOptions {
    instance: WebAssembly.Instance
    module: WebAssembly.Module
    memory?: WebAssembly.Memory
    table?: WebAssembly.Table
}

export declare type InputType = string | URL | Response | BufferSource | WebAssembly.Module;

/** @public */
export declare interface InstantiatedSource extends WebAssembly.WebAssemblyInstantiatedSource {
    napiModule: NapiModule;
}

/** @public */
export declare function instantiateNapiModule(
/** Only support `BufferSource` or `WebAssembly.Module` on Node.js */
wasmInput: InputType | Promise<InputType>, options: InstantiateOptions): Promise<InstantiatedSource>;

/** @public */
export declare function instantiateNapiModuleSync(wasmInput: BufferSource | WebAssembly.Module, options: InstantiateOptions): InstantiatedSource;

/** @public */
export declare type InstantiateOptions = CreateOptions & LoadOptions;

/** @public */
export declare function loadNapiModule(napiModule: NapiModule, 
/** Only support `BufferSource` or `WebAssembly.Module` on Node.js */
wasmInput: InputType | Promise<InputType>, options?: LoadOptions): Promise<WebAssembly.WebAssemblyInstantiatedSource>;

/** @public */
export declare function loadNapiModuleSync(napiModule: NapiModule, wasmInput: BufferSource | WebAssembly.Module, options?: LoadOptions): WebAssembly.WebAssemblyInstantiatedSource;

/** @public */
export declare interface LoadOptions {
    wasi?: ReactorWASI;
    overwriteImports?: (importObject: WebAssembly.Imports) => WebAssembly.Imports;
    beforeInit?: (source: WebAssembly.WebAssemblyInstantiatedSource) => void;
    getMemory?: (exports: WebAssembly.Exports) => WebAssembly.Memory;
    getTable?: (exports: WebAssembly.Exports) => WebAssembly.Table;
}

/** @public */
export declare class MessageHandler {
    onLoad: (data: OnLoadData) => InstantiatedSource | Promise<InstantiatedSource>;
    instance: WebAssembly.Instance | undefined;
    napiModule: NapiModule | undefined;
    messagesBeforeLoad: any[];
    constructor(options: HandleOptions);
    handle(e: any): void;
}

/** @public */
export declare interface NapiModule {
    imports: {
        env: any
        napi: any
        emnapi: any
    }
    exports: any
    loaded: boolean
    filename: string
    childThread: boolean
    emnapi: {
        syncMemory<T extends ArrayBuffer | ArrayBufferView> (
        js_to_wasm: boolean,
        arrayBufferOrView: T,
        offset?: number,
        len?: number
        ): T
        getMemoryAddress (arrayBufferOrView: ArrayBuffer | ArrayBufferView): PointerInfo
    }

    init (options: InitOptions): any
    spawnThread (startArg: number, errorOrTid?: number): number
    startThread (tid: number, startArg: number): void
    initWorker (arg: number): void
    executeAsyncWork (work: number): void
    postMessage?: (msg: any) => any
}

/** @public */
export declare interface NodeBinding {
    node: {
        emitAsyncInit: Function
        emitAsyncDestroy: Function
        makeCallback: Function
    }
    napi: {
        asyncInit: Function
        asyncDestroy: Function
        makeCallback: Function
    }
}

/** @public */
export declare interface OnLoadData {
    wasmModule: WebAssembly.Module;
    wasmMemory: WebAssembly.Memory;
}

/** @public */
export declare interface PointerInfo {
    address: number
    ownership: 0 | 1
    runtimeAllocated: 0 | 1
}

/** @public */
export declare interface ReactorWASI {
    readonly wasiImport?: Record<string, any>;
    initialize(instance: object): void;
    getImportObject?(): any;
}

export declare const version: string;

export { }
